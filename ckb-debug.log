#############################################
#
#	Important information regarding macOS.
# macOS is no longer officially supported.
# For more information, please refer to
# [issue #660](https://github.com/ckb-next/ckb-next/issues/660)
#
#############################################
# (map - debug, text symbols)
#
# []  --> TODO
# [-] --> nothing to do here, come along...
# [x] --> task completed.
# [!] --> Review needed, 'check this.'
#
######### OPTION permissions
# El kernel tiene tres imortantes cualidades; es prioritario,
# el código es reentrante y es político agnóstico. Junto a este
# último rasgo, han sido desarrolladas una serie de funciones,
# algo así como unas macro, que facilitan la comunicación entre
# el kernel y las aplicaciones.
# Cuando un controlador de dispositivo no encuentra la forma de
# trabajar con un archivo, debido a la falta o insuficiencia del
# permiso adecuado, la función que llama a dicho recurso, podría
# concluirse que no reune las CAPACIDADES adecuadas.
#
# Pero esto es así, únicamente cuando hablamos de la interfase de
# sistema en /sys, o de algún archivo de proceso en /proc.
# El error está advirtiendo que no encuentra el archivo represen-
# tativo del demonio de aplicación; en /etc/systemd/system/ y del
# binario que supuestamente debe instalarse durante la fase de
# instalación(make install) sobre el directorio /bin. No debería
# ser /bin, sino /usr/bin, pero imaginemos que es lo mismo!.
#
# Éste problema específico con la unidad de servicio 'xxx.service'
# era de esperar, puesto que la instalación se realiza desde un
# usuario no administrador. Una busqueda sobre el directorio BUILD
# para comprobar que efectivamente la construcción extrae de forma
# adecuada la unidad de servicio, demuestra que está presente y la
# información es correcta.
#
# [] - What function is calling the daemon?
# [] - What is the required permision?
# [x] - show a function implementation of a capable function:
#			int capable(int capabillity); it returns noncero if the
#			process has the given capabillity.
# [x] - Header from kernel source: <linux/capabillity.h> defines
#			 the various CAP_ symbols describing a user-space process
#			 may have.
# The error says this:
# Failed to get unit file state for ckb-daemon.service:
#		No such file or directory
#############################################
#		 OPTION pulseadio
# =====================
# The man page of the subsystem(pulseadio) :
# 		it is runing  as a background process (PA) -> pidof(pulseadio).
# 		--start option will fire-up the deamon at boot.
# I think the problem is that some required application complements
# are missing, as stated by the message:
# =====================
# CMake Warning at src/animations/mviz/CMakeLists.txt:31 (message):
#   Missing PulseAudio API.  Not building mviz.
# =====================
#
#############################################
#		 OPTION systemd.unit
# =====================
# At this point of the build, many dependencies aren't installed.
# It's a cryptic message because it refers to a systemd unit file
# not builded yet, and the error itself is confusing.
#
#############################################
#		 OPTION .gitClone
# =====================
# Git executable not found.
# 	Failed to get unit file state for ckb-daemon.service:
# 		No such file or directory
# 	Failed to get unit file state for ckb-next-daemon.service:
# 		No such file or directory
# =====================

# [] Why a git executable, looks like a warning ?
# [] Document after the build completes, the state of this error:
#
#############################################
#		 OPTION dependencies
# =====================
# 		REQUIRED COMPONENTS Core Widgets Network Gui
# ******* Qt5Config.cmake provided by qt5-qtbase-devel
# ******* instaled qt5
# ******* instaled qt5-qtbase-devel
# ******* instaled qt5-qtbase-gui
# ******* instaled quazip-qt5-1.2-2.el9.x86_64.rpm
# ******* instaled quazip-qt5-devel-1.2-2.el9.x86_64.rpm
# ******* instaled qt5-qtx11extras-devel
# *******          xcb-ewmh -- distro specific.
# ******* instaled xcb-util-wm
# ******* installed dbusmenu-qt5-0.9.3
# ******* instaled xcb-util-wm-devel(xcb-ewmh.pc)
# =====================
# 	DEBUG xcb-ewmh
# =====================
#
# 		[x] -- xcb-ewmh.pc file dropped on place. Problem solved.
# 				The error message build says:
# 					src/gui/CMakeLists.txt:316 can't find the package
# 					xcb-ewmh. This pkg takes another name in this distro:
# 					xcb-util-wm.
# 				The check is searching for:
# 					pkg_check_modules(XCB_EWMH xcb-ewmh)
# 		[-] You can try to oring the real pkg name in your distro, or
# 				 to try another way touching source:
# 						xcb/xwindowdetector.cpp
# 				 The name of the package configuration file(*.pc)
# 				 could be anything. The convention states its name
# 				 as the name of the package, but both are separated
# 				 entities. The '*.pc' file just tell the cmake app
# 				 where to find headers and libs. Metadata if you wish(*.pc).
#					The rpm list option command dumps a bunch of directories
# 				of shared objects(.so), but there are two interesting files:
# 					/usr/lib64/libxcb-ewmh.so.2    and
# 					/usr/lib64/libxcb-ewmh.so.2.0.0
# 					prompt:> pkg-config --exists xcb-util-wm
# 					prompt:> echo $?
# 					1
#
# Extract from /usr/share/doc/xcb-util-wm-0.4.1/README:
# About XCB util-wm module
# =====================
# 	debug util-wm
# =====================
# Distro specific alternative:
# XCB util-wm module provides the following libraries:
#
#   - ewmh: Both client and window-manager helpers for EWMH.
#   - icccm: Both client and window-manager helpers for ICCCM.
#
#  The package-config(.pc) file is missing. A new one was droped
#  down '/usr/lib64/pkgconfig/'. FileName: xcb-ewmh.pc
#  	The (*.pc) file comes from the developer pkg, installing just
#  	foo.rpm is not good enough, you should install the foo-dev.rpm
#  	to get the *.pc in place.
# [x] Write the package config file(.pc):
# 		prefix=/usr
# 		exec_prefix=${prefix}/lib64/xcb-ewmh
# 		includedir=${prefix}/include
# 		libdir=${exec_prefix}/lib64
#
# 		Name: xcb-ewmh
# 		Description: Client and window-manager helpers for EWMH.
# 		Version: 0.4.1
# 		Requires.private: xcb >= 1.11
# 		Cflags: -I${includedir}/xcb-ewmh
# 		Libs: -L${libdir} -lxcb-ewmh
#############################################
# =====================
# 	debug dbusmenu-qt5
# =====================
# 				Another missing dependencie, build message:
# 				-- dbusmenu-qt5 was not found.
# 				-- The same problem as above; it seems that the package
# 				-- configuration(.pc) file is missing.
# 				The package conig file(.pc) is available through
# 				the development pkg.
# 				It reflects another version:
# 				0.9.3. and dbus.pc shows 0.9.2. Why?
#
#					rpm -q dbusmenu-qt5-devel;
#	        rpm -q dbusmenu-qt5;
#	        pkg-config --modversion dbusmenu-qt5;
#
#############################################
#
#	OPTION target
#	================
#	[x] Try to build without the offending file:
#		[x] Commented in(input_mac_vhid.h) file: +105 in src/daemon/CMakeLists.txt
#				[x] Check the BUILD.
#				[x] push the file with changes.
#				[x] Build:
#						The Commented in(input_mac_vhid.h) continues to being
#						referenced in another way, because the error persist.
#						[x] Try to build with a single target by changing the
#						   declaration at +60 in src/daemon/CMakeLists.txt
#						[x] Comment the file: request_hid_mac.h in the list.
#						   The same happens with: request_hid_mac.h.
#						   There should be a cross reference from mac target
#						   digging in the list of common files.
#						[x] Push the changes.
#						[x] Build again. ok.
#		[x] New tarball without file: input_mac_vhid.h and request_hid_mac.h.
#			 The tarball was constructed initially WITHOUT those files,
#			 Nothing to do here. If OPTION target fails, it will be needed
#			 [-] to tar another ball.
#			 		 No need to build another tarball at this point.
#
#		There are three files down /src/daemon/{structures.h:5,
#		includes.h:71, command.c:3} that points to keymap_mac.h.
#		There are three files that points to keymap.h. At the same
#		time, this file has a losed reference to the Mac source.
#		The packager decides to exclude all macintosh source from this
#		pkg, due the developer decision to not continue the mac support
#		to the driver.
#
#		[x] Update the source to avoid cross references to NOT INCLUDED
#			 Macintosh source.
#			[-] Source: src/daemon/structures.h has a reference to input_mac_vhid.h
#				 You should to inhibit the header.
#			[-] Source: src/daemon/includes.h. It refences to src/daemon/structures.h
#			[-] Source: src/daemon/command.c
#			[x] SUMMARY:
#					[x] commented the line 8: #include "input_mac_vhid.h" on
#					   src/daemon/structures.h
#					[x] commented the line 4: #include "keymap_mac.h" on
#					   src/daemon/keymap.h
#						[x] Push the changes.
#						[x] Build again:
#								The error dumped a new build arround: [ 30%] Built target pipe.
#								It is a good improvement. Those comments has been worked, and
#								no reference to keymap_mac.h nor input_mac_vhid.h
#								appeared again. ok, for this step.
#						Another include of the header "request_hid_mac.h" appears in the
#						log error: No such file or directory. Good, that indicates
#						the tarball is solid.
#			[x] Clean the cross reference.
#					Source: src/daemon/main.c:6 points to request_hid_mac.h
#					[x] Push the changes.
#					[x] Build again:
#							The error dumped a new build arround: [ 51%] Building CXX object
#							I think a devel pkg is missing: xcb-util-wm-devel? [CORRECT]
#		[x] This is another type of error, and has nothing to do with errors of
#			 target mac.
#			 The new error: xcb/xcb_ewmh.h: No such file or directory.
#			 Local includes, where the header file should be placed is missing
#			 the header:/usr/include/xcb.
#			[x] Check the pkg upstream: No devel pkg upstream.
#			[x] Locate the exact header: xcb_ewmh.h
#			[x] query list for files: rpm -ql pkg
#			[x] Download the pkg: Manually downloaded
#			[x] install leaky files.
#			[x] Build again:
#			    The build has been completed entirely: [100%] Built target ...
#			    But. It was used the script 'quickinstall', in the process of
#					building, so the script did their job to the end, and that
#			    implies the installation of the application. This is a problem,
#			    because it breaks the step behaviour of the rpm system.
#			    In other words is needed to modify the script to not install
#			    nothing since this is the rpm task.
#			    I understand the sense of writing the script in that way,
#			    because without a ckb-next.rpm file, the user needs some
#			    way to make the application run.
#			    It seems a stupid think to left the script to continue to
#			    the end, but it is not, since this is the first build of
#			    the application and the environment was setup to test anything.
#			    There are some task that clearly needs to be modified, and
#			    a new todo list will be made to track those changes.
#			    The next todo list starts from a point where the application
#			    was builded and installed gracefully.
#
#	TODO (building the rpm file):
#	##############################################################
#	## You are working on a development project. The upstream		##
#	## repo works with git, and you should do the same.					##
#	## 		WARNING  	WARNING  	WARNING  	WARNING  	WARNING  			##
#	##						Think before, and do later										##
#	##############################################################
#
#	[] Planing the build:
#    Now that has been tested the script 'quickinstall', appears the option
#    of continue to using it, or take proffit of commands defined
#    and update the spec accordingly. This means write each command
#    defined in 'quickinstall' script, and put it on their respective
#    section in the spec. so:
#    [x] What is the best choice; re-write the spec with all the staff
#    		done in quickinstall, or modify the script to not interfere
#    		with the rpm build process?
#				[-] Modify the 'quickinstall' script.
#				[x] To include the 'quickinstall' commands in the ckb-next.spec.
#    [] There are two implicit tasks to be done:
#		 		[] single target:
#					 rpm files are platform specific files, no need to build
#					 'any' target.
#		 		[x] Take off the install target:
#						It should be updated the spec file, with the commands defined
#						in the script 'quickinstall'.
#		 [x] Split the tasks done in 'quickinstall' and try to find the
#				apropiate place of that task in the spec; i.e:
#				[x] Package information: this is a 'global' section
#						where information about the application is implemented.
#						There are definitions of type name, version, major and minor
#						control version	number, etc.
#						[x] The excludeos directive seems to have no effect.
#							 Define an apropiate one(Excludearch) and delete it.
#				[x] %prep:
#						This task takes the tarball and place the files.
#						The tarball is solid and you can use it without modification
#						for THIS PLATFORM. There are no Mac files.
#				[x] %build
#				[x] %install
#				[x] %clean
#				[x] %files : this is done. ok.
#				[x] %pre
#				[-] %post
#				[x] %preun
#				[-] %postun
#		 [x] Dive in the rpm 'method', and grab the script information.
#				The script rpm functionallity it's tied to a process that
#				take an action when the installed package's spec change
#				their status. It is usefull when is needed to change a
#				package installation based on other pkg. Triggers don not
#				replace dependencies.
#		 [x] Now you know the exact dependencies the application needs.
#				A package depends on other pkg, there are four types of
#				rpm dependencies:
#				- Requires: a pkg requires a capability provided by another.
#				- BuildRequires: as above, but involved in the build process.
#				- Provides: the capabilities your pkg provides.
#				- Conflicts: pkg conflicts with a capability provided by other.
#				- Obsoletes: when the installation of a pkg providing a
#					capability, obsoletes similar capability provided by another
#					package. Such situation occurs when a package is renamed.
#
#	##############################################################
#	## BUILD DEVELOPMENT:                                    		##
#	##   - Second stage                               					##
#	## 	 - Updated spec(whithout quickinstall scripts).    			##
#	##						                          										##
#	##############################################################
#
# [] Build with short circuit.
# 	[x] pre stage: verified file permissions and owner. OK.
# 								 The log of this stage is showing the user
# 								 who runs the build application, but the rule
# 								 defined in the specs works as it should be.
# 	[]  build stage:
# 		 [x] Check dependencies:
# 		 		      qt5-qtbase-devel
# 		 		      qt5-qtx11extras-devel
# 		 		      quazip-qt5
# 		 		      quazip-qt5-devel
# 		 		      xcb-util-wm-devel
#				[] build error:
# 			>> cmake/modules/FindUDEV.cmake:82
# 			>>	(find_package_handle_standard_args)
# 			>> src/daemon/CMakeLists.txt:56 (find_package)
# 			>> Could NOT find UDEV (missing: UDEV_LIBRARY UDEV_INCLUDE_DIR)
#   			This cryptic message, seems to be speaking about the library,
# 				but it could not be that. Many applications depends on a
# 				acceptable installation of UDEV, bla, bla, wide system resource.
# 				The cryptic message also says ... missing: UDEV_INCLUDE_DIR,
# 				and that variable is often defined on a .pc(package config)
# 				file.
# 				It's more weird than that, because the first time i builded and
# 				installed the driver, the log out/error no mention that
# 				error, at all. Cosmic Ray?
# 				[x] Install development package. OR
# 						[-] Write a xxx.pc. The lib is there.
# 				[x] Update spec dependencies.
# 						[x] Modified spec to add dependencie to libudev(xxx.pc).
# 				[] And you should start thinking to write a readme style file,
# 					 documenting all that, specially the dependencies to a xxx.pc.
# 				[x] Review build targets on the spec.
# 						[x] Modified spec to build a single target.
# 				[x] Push changes.
# 	REGRESION:
# 			This regresion appears because you commented those lines
# 			after packaging the source on the tarball. So every time
# 			you runs a new build, the original code it's droped on place.
# 			(False if you are using short-circuit mechanism).
#			[x] SUMMARY:
#					[x] commented the line 8: #include "input_mac_vhid.h" on
#					   src/daemon/structures.h
#					[x] commented the line 4: #include "keymap_mac.h" on
#					   src/daemon/keymap.h
#						[x] Push the changes.
# 				Note: It was changed both files uncompressing first
# 							and editing the files with vi editor. You must
# 							'!' force the action because the files opens in
# 							ro. It's not a glamorouse action, but if you are
# 							working with few files, it is ok.
# 				Note: (man rpmbuild):
# 							"[-bc] Do the '%build' stage from spec file
# 							(after doing the %prep stage)...
# 							Here it's not doing that. It's re-using the
# 							source skiping %prep stage, Why?
# 							Option A: cosmic ray again.
# 							Option B: i'm using --short-circuit. I think i'm
# 							wrigth. So if the flag is turned off it should
# 							begins the process again!
# 				Observation: The %prep directive on the spec file leaks
# 							the declaration 'rm -rf $RPM_BUILD_ROOT'.
# 							It has sense because once placed the extracted files
# 							isn't needed to alter the source in any form.
# 							And that fact, affects the 'short circuit' behaviour
# 							if some file are modified in any way; the flag doesn't
# 							recreate those files, that are placed staticaly.
#
# 	PATCHING:
# 	 "Patches are important because they allow you to start
# 		with pristine sources..."
# 	 Any one that opens the x.rpm could see those changes
# 	 over the patches, and decide if agree with that or not.
#
#	##############################################################
#	## BUILD DEVELOPMENT:                                    		##
#	##   - Patching with git                         						##
#	##############################################################
#	SUMARY:
#		Using git pacthing means an exact copy of the modified files
# 	where they were. It's not enough to copy the files you want
# 	to modify on any directory. This will not work.
#		This comment reflects a similar sitaution on a foi dir, where
#		you have been copied the 'selected' files implent a modificiation
#		and then patch the commit where the modification take place.
#		It will not work because the path to those files it doesn't
#		match. When trying to apply the patch, it will fail.
#		So there are two forms to proceed with that:
#			1.- If the source is a git repository, ask in some maner
#					if the modification is acceptable, and do the patching
#					there.
#			2.- Copy the repository, to a local one, and do the changes
#					there.
#			3.- (hack, not tested) Open the file patch, and modify the
#					path. It's just raw string, it should work.
#	I don't have  special interest on cosmic ray, but...
#		How can fail an instruction (get processors number) on a build
#		and get a successfull work on previous ones?
#
#		1.- The short circuit mechanism it's skiping the processor test,
#				on subsequent builds. This is a %pre script.
#		2.  Cosmic ray.
#		3.  Updated scriplet style on spec. Variable substitution
#				clearify the spec reads. It is avoided to poping an
#				innecessary shell; instead, it's calling just the app;
#				the available processor number test.
#
#
#
#
#
#	##############################################################
#		SYSTEM ALERT:
#			timeStamp: Mon Sep  9 21:02:47 -0400 2024
#			That mark clearly indicate a wrong date set-up. It's a trivial
#			info because the underliying system porpouse it's dedicated to
#			test a build. It has no other porpouse. But the lastlog log
#			it's displaying a login from the router IP/gateway.
#			A possible explanation:
#				A latency between the dhcp server(DNSMASK) in this case,
#				and the vm server.
#			  No other effect has been detected, the usual login from
#				user, works as spected to work.
#			ausearch:
#				cmd --> ausearch -c sshd
#				It is just showing the failed login. File log: log-ausearch.log
#			lastb:
#				It's not clear why the login has failed, it shows a symbol
#				on the login attempt, and could be meaning a misstyped
#				'try' to connect: "(unknown ttyS0" . File: badLogs.log
#			last: same.
#
#
#	##############################################################
#	## BUILD DEVELOPMENT:                                    		##
#	##   - Last stage                               						##
#	## 	 - Clean-up unnecesary files and mechanics     					##
#	##		 as git-packaging.				                          	##									##
#	##############################################################
#	C.I. Continuous integration. Git have an engine to automate
#	build testing. You are not working on the source. Remove
#	references to it.
